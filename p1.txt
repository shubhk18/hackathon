#!/bin/bash

# Check if enough arguments are passed
if [ $# -ne 2 ]; then
  echo "Usage: $0 <template_file> <label_name>"
  exit 1
fi

# Input arguments
template_file="$1"
label_name="$2"
temp_file="temp_output.txt"

# Validate the template file exists
if [ ! -f "$template_file" ]; then
  echo "Error: Template file '$template_file' does not exist."
  exit 1
fi

# Extract content for the specified label
awk -v label="$label_name" '
  BEGIN {found=0} 
  # Match label (e.g., L1:)
  $0 ~ label ":" {found=1; next} 
  # Stop on the next label or end of file
  found && /^L[0-9]+:/ {found=0} 
  # Print content if inside the matching label
  found {print}
' "$template_file" > "$temp_file"

# Check if content was written
if [ -s "$temp_file" ]; then
  echo "Content for '$label_name' has been written to $temp_file."
else
  echo "Error: No content found for label '$label_name'."
  rm -f "$temp_file"
fi


Here’s a detailed explanation of the awk block in the script:

awk -v label="$label_name" '
  BEGIN {found=0} 
  $0 ~ label ":" {found=1; next} 
  found && /^L[0-9]+:/ {found=0} 
  found {print}
' "$template_file" > "$temp_file"

Explanation of Each Line:
	1.	awk -v label="$label_name":
	•	This sets a variable label in awk to the value of $label_name passed from the script.
	•	-v is used to pass shell variables into the awk program.
	2.	BEGIN {found=0}:
	•	The BEGIN block runs once before processing any lines.
	•	Here, found is initialized to 0. This is a flag to indicate whether we’re inside the desired label’s content.
	3.	$0 ~ label ":" {found=1; next}:
	•	$0 refers to the current line being processed.
	•	$0 ~ label ":" checks if the current line matches the pattern <label>:, where <label> is the name of the desired label (e.g., L1:).
	•	If the line matches, the flag found is set to 1 to indicate that we’re now inside the desired label’s content.
	•	next skips to the next line, ensuring the label line itself is not processed further.
	4.	found && /^L[0-9]+:/ {found=0}:
	•	This checks if:
	•	found is 1 (we’re inside the desired label’s content), and
	•	The current line matches the pattern L[0-9]+:, which represents the start of a new label (e.g., L2: or L3:).
	•	If both conditions are true, it means we’ve reached the next label, so we set found back to 0 to stop processing.
	5.	found {print}:
	•	If found is 1 (we’re inside the desired label’s content), the current line is printed.
	•	This effectively extracts all lines between the desired label and the next label or the end of the file.
	6.	"$template_file" > "$temp_file":
	•	awk processes the contents of $template_file, and the extracted content is redirected to the temp_file.

Key Concepts:
	•	Pattern Matching:
	•	$0 ~ label ":" matches the label line, e.g., L1:.
	•	/^L[0-9]+:/ matches any line that starts with L followed by numbers and a colon, e.g., L2:.
	•	Flags:
	•	The found flag controls whether lines are being processed and printed.
	•	next:
	•	Ensures the label line itself is skipped and not included in the output.

Example Flow:

For the following input (template.txt):

L1:
Content for L1.

L2:
Content for L2.

L3:
Content for L3.

If label_name="L1":
	1.	Match L1: → Set found=1.
	2.	Print lines while found=1:
	•	Content for L1. is printed.
	3.	Stop when L2: is encountered → Set found=0.
